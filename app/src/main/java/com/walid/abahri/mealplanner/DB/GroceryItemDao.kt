package com.walid.abahri.mealplanner.DB

import androidx.lifecycle.LiveData
import androidx.room.*
import kotlinx.coroutines.flow.Flow

/**
 * Data Access Object for the grocery_items table
 */
@Dao
interface GroceryItemDao {
    @Query("DELETE FROM grocery_items")
    suspend fun deleteAll()

    /**
     * Get all grocery items ordered by category and name for a specific user
     */
    @Query("SELECT * FROM grocery_items WHERE user_id = :userId ORDER BY category, name")
    fun getAllItems(userId: Int): LiveData<List<GroceryItem>>
    
    /**
     * Get grocery items by category for a specific user
     */
    @Query("SELECT * FROM grocery_items WHERE user_id = :userId AND category = :category ORDER BY name")
    fun getItemsByCategory(userId: Int, category: String): LiveData<List<GroceryItem>>
    
    /**
     * Get unchecked grocery items for a specific user
     */
    @Query("SELECT * FROM grocery_items WHERE user_id = :userId AND is_checked = 0 ORDER BY category, name")
    fun getUncheckedItems(userId: Int): LiveData<List<GroceryItem>>
    
    /**
     * Insert a single grocery item
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertItem(item: GroceryItem): Long
    
    /**
     * Insert multiple grocery items at once
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertItems(items: List<GroceryItem>): List<Long>
    
    /**
     * Update a grocery item
     */
    @Update
    suspend fun updateItem(item: GroceryItem)
    
    /**
     * Delete a grocery item
     */
    @Delete
    suspend fun deleteItem(item: GroceryItem)
    
    /**
     * Update just the checked status of an item, ensuring it belongs to the user
     */
    @Query("UPDATE grocery_items SET is_checked = :isChecked WHERE id = :itemId AND user_id = :userId")
    suspend fun updateItemCheckedStatus(itemId: Int, userId: Int, isChecked: Boolean)
    
    /**
     * Delete all checked items for a specific user
     */
    @Query("DELETE FROM grocery_items WHERE user_id = :userId AND is_checked = 1")
    suspend fun deleteCheckedItems(userId: Int)
    
    /**
     * Delete all grocery items for a specific user
     */
    @Query("DELETE FROM grocery_items WHERE user_id = :userId")
    suspend fun deleteAllItems(userId: Int)
    
    /**
     * Get distinct categories for a specific user
     */
    @Query("SELECT DISTINCT category FROM grocery_items WHERE user_id = :userId ORDER BY category")
    fun getCategories(userId: Int): LiveData<List<String>>

    /**
     * Debug: Get all grocery items, regardless of user. Not for production use!
     */
    @Query("SELECT * FROM grocery_items")
    fun getAllItemsRaw(): List<GroceryItem>

    // Additional methods for new functionality

    /**
     * Get all grocery items as Flow for a specific user
     */
    @Query("SELECT * FROM grocery_items WHERE user_id = :userId ORDER BY category, name")
    fun getAllItemsFlow(userId: Int): Flow<List<GroceryItem>>

    /**
     * Get grocery items by name for a specific user
     */
    @Query("SELECT * FROM grocery_items WHERE user_id = :userId AND name LIKE '%' || :name || '%'")
    fun getItemsByName(userId: Int, name: String): Flow<List<GroceryItem>>

    /**
     * Get grocery items by category as Flow for a specific user
     */
    @Query("SELECT * FROM grocery_items WHERE user_id = :userId AND category = :category ORDER BY name")
    fun getItemsByCategory(userId: Int, category: String): Flow<List<GroceryItem>>

    /**
     * Delete auto-generated items (items with recipeSourceId)
     */
    @Query("DELETE FROM grocery_items WHERE user_id = :userId AND recipe_source_id IS NOT NULL")
    suspend fun deleteAutoGeneratedItems(userId: Int)
}