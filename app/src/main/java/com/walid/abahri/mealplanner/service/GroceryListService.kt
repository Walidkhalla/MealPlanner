package com.walid.abahri.mealplanner.service

import android.content.Context
import androidx.annotation.WorkerThread
import com.walid.abahri.mealplanner.DB.*
import com.walid.abahri.mealplanner.repository.GroceryRepository
import com.walid.abahri.mealplanner.util.UserManager
import kotlinx.coroutines.flow.first

/**
 * Service for automatically generating grocery lists from meal plans
 */
class GroceryListService(
    private val groceryRepository: GroceryRepository,
    private val mealPlanDao: MealPlanDao,
    private val recipeIngredientDao: RecipeIngredientDao,
    private val ingredientDao: IngredientDao,
    private val context: Context
) {
    
    private val userManager = UserManager.getInstance(context)

    /**
     * Generate grocery list from meal plans for a date range
     */
    @WorkerThread
    suspend fun generateGroceryListFromMealPlans(
        startDate: String,
        endDate: String,
        clearExisting: Boolean = true
    ): List<GroceryItem> {
        val userId = userManager.getCurrentUserId()
        
        // Clear existing auto-generated items if requested
        if (clearExisting) {
            groceryRepository.clearAutoGeneratedItems()
        }
        
        // Get all meal plans for the date range
        val mealPlans = mealPlanDao.getMealPlansForDateRange(userId, startDate, endDate).first()
        
        // Collect all ingredients with amounts
        val ingredientAmounts = mutableMapOf<Int, Float>() // ingredientId -> total amount
        val ingredientUnits = mutableMapOf<Int, String>() // ingredientId -> unit
        val ingredientRecipes = mutableMapOf<Int, MutableSet<Int>>() // ingredientId -> recipe IDs
        
        for (mealPlan in mealPlans) {
            val recipeIngredients = recipeIngredientDao.getRecipeIngredients(mealPlan.recipeId).first()
            val servingMultiplier = mealPlan.servings.toFloat()
            
            for (recipeIngredient in recipeIngredients) {
                val ingredientId = recipeIngredient.ingredientId
                val amount = recipeIngredient.amount * servingMultiplier
                
                // Aggregate amounts (assuming same unit for now - in real app you'd need unit conversion)
                ingredientAmounts[ingredientId] = (ingredientAmounts[ingredientId] ?: 0f) + amount
                ingredientUnits[ingredientId] = recipeIngredient.unit
                
                // Track which recipes use this ingredient
                ingredientRecipes.getOrPut(ingredientId) { mutableSetOf() }.add(mealPlan.recipeId)
            }
        }
        
        // Create grocery items
        val groceryItems = mutableListOf<GroceryItem>()
        
        for ((ingredientId, totalAmount) in ingredientAmounts) {
            val ingredient = ingredientDao.getIngredientById(ingredientId).first()
            val unit = ingredientUnits[ingredientId] ?: ingredient?.defaultUnit ?: "unit"
            
            if (ingredient != null) {
                val groceryItem = GroceryItem(
                    userId = userId,
                    name = ingredient.name,
                    amount = totalAmount,
                    unit = unit,
                    category = ingredient.category,
                    isChecked = false,
                    recipeSourceId = null // Multiple recipes, so we don't specify one
                )
                
                groceryItems.add(groceryItem)
                groceryRepository.insertGroceryItem(groceryItem)
            }
        }
        
        return groceryItems
    }

    /**
     * Generate grocery list for a specific week
     */
    @WorkerThread
    suspend fun generateWeeklyGroceryList(weekStartDate: String): List<GroceryItem> {
        val endDate = calculateWeekEndDate(weekStartDate)
        return generateGroceryListFromMealPlans(weekStartDate, endDate)
    }

    /**
     * Add missing ingredients from a recipe to grocery list
     */
    @WorkerThread
    suspend fun addRecipeIngredientsToGroceryList(recipeId: Int, servings: Int = 1) {
        val userId = userManager.getCurrentUserId()
        val recipeIngredients = recipeIngredientDao.getRecipeIngredients(recipeId).first()
        
        for (recipeIngredient in recipeIngredients) {
            val ingredient = ingredientDao.getIngredientById(recipeIngredient.ingredientId).first()
            
            if (ingredient != null) {
                val amount = recipeIngredient.amount * servings
                
                // Check if this ingredient is already in the grocery list
                val existingItems = groceryRepository.getGroceryItemsByName(ingredient.name).first()
                
                if (existingItems.isEmpty()) {
                    // Add new item
                    val groceryItem = GroceryItem(
                        userId = userId,
                        name = ingredient.name,
                        amount = amount,
                        unit = recipeIngredient.unit,
                        category = ingredient.category,
                        isChecked = false,
                        recipeSourceId = recipeId
                    )
                    groceryRepository.insertGroceryItem(groceryItem)
                } else {
                    // Update existing item amount
                    val existingItem = existingItems.first()
                    val updatedItem = existingItem.copy(
                        amount = existingItem.amount + amount
                    )
                    groceryRepository.updateGroceryItem(updatedItem)
                }
            }
        }
    }

    /**
     * Smart grocery list consolidation - combine similar items
     */
    @WorkerThread
    suspend fun consolidateGroceryList(): List<GroceryItem> {
        val userId = userManager.getCurrentUserId()
        val allItems = groceryRepository.getAllGroceryItems().first()
        
        // Group items by name and category
        val consolidatedItems = mutableListOf<GroceryItem>()
        val processedNames = mutableSetOf<String>()
        
        for (item in allItems) {
            if (item.name in processedNames) continue
            
            // Find all items with the same name
            val similarItems = allItems.filter { it.name == item.name && !it.isChecked }
            
            if (similarItems.size > 1) {
                // Consolidate amounts (assuming same unit)
                val totalAmount = similarItems.sumOf { it.amount.toDouble() }.toFloat()
                val consolidatedItem = item.copy(amount = totalAmount)
                
                // Delete old items and insert consolidated one
                similarItems.forEach { groceryRepository.deleteGroceryItem(it) }
                groceryRepository.insertGroceryItem(consolidatedItem)
                consolidatedItems.add(consolidatedItem)
            } else {
                consolidatedItems.add(item)
            }
            
            processedNames.add(item.name)
        }
        
        return consolidatedItems
    }

    /**
     * Calculate end date for a week (7 days from start)
     */
    private fun calculateWeekEndDate(startDate: String): String {
        // Simple date calculation - in real app you'd use proper date handling
        val parts = startDate.split("-")
        val year = parts[0].toInt()
        val month = parts[1].toInt()
        val day = parts[2].toInt()
        
        // Add 6 days (for a 7-day week)
        val endDay = day + 6
        
        // Simple calculation - doesn't handle month/year overflow properly
        return "$year-${month.toString().padStart(2, '0')}-${endDay.toString().padStart(2, '0')}"
    }

    /**
     * Get grocery list organized by categories
     */
    suspend fun getGroceryListByCategory(): Map<String, List<GroceryItem>> {
        val allItems = groceryRepository.getAllGroceryItems().first()
        return allItems.groupBy { it.category }
    }

    /**
     * Mark ingredients as purchased and remove from active list
     */
    @WorkerThread
    suspend fun markIngredientsPurchased(ingredientNames: List<String>) {
        for (name in ingredientNames) {
            val items = groceryRepository.getGroceryItemsByName(name).first()
            items.forEach { item ->
                val updatedItem = item.copy(isChecked = true)
                groceryRepository.updateGroceryItem(updatedItem)
            }
        }
    }
}
